syntax = "proto3";
package worker_server_grpc_api;

//~/Programs/protoc-3.10.1-linux-x86_64/bin/protoc  -I worker_server_grpc_api --go_out=plugins=grpc:worker_server_grpc_api worker_server_grpc_api/worker_server.proto

// Parameter used for Empty inputs
message EmptyParameter {
}

// Ack/Nack- Response message with comment
message AckNackResponse {
    bool acknack = 1; // True=Ack, False=Nack
    string comments = 2; //Comments if needed
}

// The Client register service definition.
// ***********************
service WorkerServer {

    //Main coordinator sends task to worker with this service
    rpc WorkerTask (messageToWorker_struct) returns (AckNackResponse) {
    }

    //Main coordinator, or other worker on same IP, can check if worker is still alive with this service
    rpc AreYouAlive (EmptyParameter) returns (AckNackResponse) {
    }


}


message header_struct {
    int32 headerId = 1;
    string headerText = 2;
    int32 headerType = 3;
    string headerTypeName = 4;
    int32 headerValueCount = 5;
    int32 numberOfFormulas = 6; //Number of formulas that are referencing valueSets for this header
    int64 multiplicatorFactor = 7; //Multiplies the number of combination previous Headers generated
    int64 numberOfRowsGenerated = 8; // Hmmm, don't know what this is for
    repeated bool valueComparator = 9; // Every value has True/False depending of if it is referenced or not in a formula
}
// TODO Ev. ska valueComparator flyttas till Valu och ligga på lägsta nivå??


message valueSet_struct {
    int32 valueSetId = 1; // Id for value
    int32 HeaderId = 2; // Id of Header that value belongs to
    string HeaderText = 3; //Text of Header that value belongs to
    string ValueText = 4; //Text of the value
    int32 IndexAtHeader = 5; //The index that the value should be presented unnder header
}

message ruleIdentifier {
    int32 ruleId = 1; // Id of type of rule
    int32 headerId = 2; // Id of Header where rules is placed under
    string headerText = 3; //Text of where rules is placed under
    int32 headerIndex = 4; //The index, left to right, of the Header where the ruled is placed under
}

// Is used to compose a formula. One formula consists of many ruleBaseBlocks
message ruleBaseBlock_struct {
    int32 buildingBlockType = 1; // Describes the type, e.g. values: 'Header:HeaderValue', logical operator: 'AND', 'OR', 'NOT', separators: '(', ')'
    int32 valueId = 2; // Id of the building block
    string buildingBlockValue = 3; // Text of building block belongs to logical operator: 'AND', 'OR', 'NOT', separators: '(', ')'
    int32 headerIndexIfappropiant = 4; //
}

// The complete rule
message rule_struct {
    ruleIdentifier ruleIdentifier = 1; // Id of rule
    string requirement = 2; // Reference to the requirement addressed by the rule
    repeated ruleBaseBlock_struct ruleBaseBlocks = 3; //  The built by RuleBaseBlocks
    string ruleText = 4; // This is a summary for text found in 'ruleBaseBlocks'
    int32 ruleType = 5; // Id of the type of rule, e.g. 0=Standard rules, 1=Rules based on User Choices
    string ruleTypeName = 6; // Name of the Rule Type "Standard rules", "Rules based on User Choices"
    string messageToUserOnTrue = 7; // Message to user when Rule Fires True, e.g. "Check Print out"
    string messageToUserOnFalse = 8; // Message to user when Rule Fires False e.g. "Check E-mail"
    int32 messageToFenixOnTrue = 9; // Message to Fenixhen Rule Fires True, e.g. "1003"
    int32 messageToFenixOnFalse = 10; // Message to Fenixhen Rule Fires True, e.g. "99007"
}

// Information sent to worker about Headers, Values and Rules
message combinationObject_struct {
    repeated header_struct headers = 1; // All Header Information
    repeated valueSet_struct valueSets = 2; // All Values belonging to Headers
    repeated rule_struct rules = 3; // All Rules
}

// Workload sent to Worker from Mother
message messageToWorker_struct {
    int32 startOfBatch = 1; // Row where batch is starting
    int32 batchSize = 2; // Batch size
    combinationObject_struct combinationObject = 3; // Information about Headers, Values and Rules
    string task_uuid = 4; // Id of this Task
    string task_name = 5; // Name of the Task
}

// Defines the type of rule
message ruleType_struct {
    int32 id = 1; // Id of Rule Type
    string ruleTypeName = 2; // The name of the Rule Type
    string ruleTypeDescription = 3; // A longer description of the Rule Type
    int32 executeAfterRuleTypeId = 4; // The Id of a Rule Type where this Rule Type validates after
    bool actOnPreviousTrueOrFalse = 5; // Act on previous result sets True or False
}

// Defines the type of Header
message headerType_struct {
    int32 id = 1; //Id of Header Type, e.g. 1="Test data Header", 2="User choices Header", ...
    string typeName = 2; // Name of the Type e.g. "Test data Header", "User choices Header"...
}

/*
type header_struct struct {
headerId              int
headerText            string
headerType            int
headerTypeName        string
headerValueCount      int
numberOfFormulas      int   //Number of formulas that are referencing valueSets for this header
multiplicatorFactor   int64 //Multiplies the number of combination previous Headers generated
numberOfRowsGenerated int64 // Hmmm, don't know what this is for
valueComparator       []bool // Every value has True/False depending of if it is referenced or not in a formula
}

type valueSet_struct struct {
valueSetId int
HeaderId   int
HeaderText string
ValueText  string
}

type ruleIdentifier struct {
ruleId      int
headerId    int
headerText  string
headerIndex int
}

type ruleBaseBlock_struct struct {
buildingBlockType       int // Describes the type, e.g. values: 'Header:HeaderValue', logical operator: 'AND', 'OR', 'NOT', separators: '(', ')'
valueId                 int
buildingBlockValue      string
headerIndexIfappropiant int
}

type rule_struct struct {
ruleIdentifier        ruleIdentifier
requirement           string
ruleBaseBlocks        []ruleBaseBlock_struct
ruleText              string //This is a summary for text found in 'ruleBaseBlocks'
ruleType              int
ruleTypeName          string
messageToUserOnTrue   string
messageToUserOnFalse  string
messageToFenixOnTrue  int
messageToFenixOnFalse int
}

type combinationObject_struct struct {
headers   []header_struct
valueSets []valueSet_struct
rules     []rule_struct
}

type messageToWorker_struct struct {
startOfBatch int32
batchSize    int32
combinationObject combinationObject_struct
}

*/